# AGENTS Instructions

This file provides guidance to AI Agents when working with code in this repository.

## Project Overview

KSwitch is a native macOS app for managing Kubernetes contexts and monitoring Flux Operator GitOps clusters.
Built with SwiftUI, requires macOS 15+ and Swift 6.2+.

## Build Commands

```bash
make build        # Build debug binary only
make test         # Run all tests (requires Xcode toolchain for Swift Testing)
make dev          # Build and launch in debug mode (fast iteration, no Sparkle)
make run          # Build and launch in production mode (release build, Sparkle enabled)
make clean        # Remove build artifacts and .app bundle
make reset        # Delete app settings from ~/Library/Application Support/KSwitch
make logs-stream  # Stream app logs in real-time
```

Run a single test:
```bash
swift test --filter ClusterTests/clusterUsesDisplayNameWhenSet
```

## Architecture

Three-layer architecture following Domain-Driven Design:

```
Sources/
├── Domain/           # Pure business logic, no dependencies on Infrastructure or SwiftUI
├── Infrastructure/   # Technical implementations (Shell, file system, notifications)
└── App/              # SwiftUI views and app entry point
```

### Domain Layer (`Sources/Domain/`)
- Models: `Cluster`, `ClusterStatus`, `ClusterNode`, `FluxReport`, `AppSettings`, `KSwitchError`
- Protocols: `CommandRunner` (marked `@Mockable` for testing)
- No SwiftUI imports - pure Swift with `Sendable` types

### Infrastructure Layer (`Sources/Infrastructure/`)
- `Shell/KubectlRunner` - Executes kubectl commands, uses `CommandRunner` protocol
- `Shell/ShellEnvironment` - Gets PATH from user's login shell, finds executables via `which`
- `Shell/DefaultCommandRunner` - Implements `CommandRunner` using `Process`
- `Platform/AppStorage` - Persists clusters and settings to disk
- `Platform/KubeconfigWatcher` - Watches kubeconfig file for changes
- `Platform/NotificationAlerter` - macOS notifications
- `Platform/AppLogger` - Unified logging via `os.Logger`

### App Layer (`Sources/App/`)
- `AppState` - Main `@Observable` state container, orchestrates services
- `Views/MenuBar/` - Menu bar popover UI (`MenuBarView`, `MenuBarSetupView`)
- `Views/Main/` - Main window UI (clusters list, settings, details)
- `Extensions/` - SwiftUI-specific extensions separated from Domain

## Key Patterns

**Dependency Injection for Testability**: `KubectlRunner` accepts a `CommandRunner` protocol,
defaulting to `DefaultCommandRunner`. Tests can inject `MockCommandRunner` (auto-generated by Mockable).

**Shell PATH Resolution**: App runs as a menu bar agent with minimal launchd PATH.
`ShellEnvironment` spawns a login shell (e.g. `-l -c "which kubectl"`) to find executables
in Homebrew, nix-darwin, asdf, etc.

**Actor Isolation**: Services like `KubectlRunner` and `ShellEnvironment` are `actor` types for thread safety.
`AppState` is `@MainActor`.

## Testing

Uses Swift Testing framework. Requires Xcode's toolchain:
```bash
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
```

Test files use `@Suite`, `@Test`, and `#expect()` macros:
```swift
@Suite struct ClusterTests {
    @Test func clusterUsesDisplayNameWhenSet() {
        var cluster = Cluster(contextName: "my-context")
        cluster.displayName = "My Cluster"
        #expect(cluster.effectiveName == "My Cluster")
    }
}
```

## CI

GitHub Actions workflow at `.github/workflows/test.yaml` uses `brightdigit/swift-build`
action with an Xcode fixed version to run tests on macOS runners.
